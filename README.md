# Zooverwaltung
Projekt Zooverwaltung

Einführung

Im Rahmen unserer Ausbildung zum Fachinformatiker Anwendungsentwicklung bei BITLC GmbH in Dortmund ist dieses Projekt zustande gekommen. Das Business IT Learning Center (BITLC) ist ein modernes Bildungszentrum, das an mehreren Standorten vertreten ist und mit zeitgemäßer Hard- und Software ausgestattet ist.

Projektumfeld

Im Gegensatz zu E-Learning-Angeboten setzt BITLC auf Präsenzunterricht und bietet jedem Teilnehmer eine individuelle Förderung. Der Unterricht zeichnet sich durch eine angenehme Lernatmosphäre und projektbezogenes Arbeiten aus, geleitet von hochqualifizierten Dozenten mit langjähriger Praxiserfahrung.

Projektbeschreibung

Im Rahmen unserer Ausbildung haben mein Kollege und ich eine Anwendung für den Gelsenkirchener Zoo entwickelt. Diese Software dient dazu, den Tierpflegern eine effiziente Möglichkeit zu bieten, den Zustand der Tiere vom Computer aus zu überwachen und bei Bedarf Fütterungsmaßnahmen einzuleiten. Die entwickelte Anwendung ermöglicht es den Tierpflegern:

• Den Gesundheitszustand der Tiere zu überprüfen

• Automatische Aktualisierung über die Zustände der Tiere in den verschiedenen Welten

• Fütterungsmaßnahmen direkt über die Anwendung zu initiieren

• Die Produktivität der Tierpfleger zu überprüfen 

Projektbegründung 

Der Gelsenkirchener Zoo steht vor der Herausforderung eines akuten Personalmangels, insbesondere im Bereich der Tierpflege. Die engagierten Tierpfleger leisten zwar hervorragende Arbeit, stehen jedoch aufgrund der hohen Anzahl von Tieren und der vielfältigen Aufgaben unter erheblichem Zeit- und Arbeitsdruck. Diese Situation hat uns dazu motiviert, eine Lösung zu entwickeln, die den Arbeitsalltag der Tierpfleger spürbar erleichtert und gleichzeitig die Bedürfnisse der Tiere optimal berücksichtigt.
Unsere Idee ist es, eine Anwendung zu schaffen, die die tägliche Zustandsüberprüfung und die Fütterungsprozesse deutlich effizienter gestaltet. Ziel ist es, durch eine intelligente und benutzerfreundliche Software die Zeit für diese zentralen Aufgaben zu verkürzen, ohne Kompromisse bei der artgerechten Versorgung der Tiere einzugehen.
Die Anwendung wird sicherstellen, dass jedes Tier versorgt wird. So können die Tierpfleger mehr Zeit für andere wichtige Tätigkeiten wie die Gehege pflege, medizinische Versorgung oder das Wohl der Tiere investieren. Mit diesem Projekt möchten wir nicht nur den Tierpflegern im Gelsenkirchener Zoo eine wertvolle Unterstützung bieten, sondern auch einen Beitrag zu einer nachhaltigeren und effizienteren Tierhaltung leisten. Unser Ansatz verbindet Technologie und Tierwohl auf innovative Weise und könnte langfristig auch für andere Zoos und ähnliche Einrichtungen von Interesse sein.

Technische Umsetzung 

Für die Entwicklung dieser Anwendung haben wir Visual Studio Forms genutzt. Diese Plattform ermöglichte es uns, eine benutzerfreundliche Oberfläche zu gestalten, die den Anforderungen der Tierpfleger entspricht. Die Anwendung ist so konzipiert, dass sie einfach zu bedienen ist und gleichzeitig alle notwendigen Funktionen für ein effektives Tiermanagement bereitstellt. Diese Lösung steht im Einklang mit dem praxisnahen Ausbildungsansatz der BITLC GmbH, der darauf abzielt, die Teilnehmer auf die Anforderungen des IT-Arbeitsmarktes vorzubereiten.
Das Projekt demonstriert die Fähigkeit, moderne und effiziente IT-Lösungen für spezifische Anwendungsfälle zu entwickeln, was ein zentrales Ziel der Ausbildung zum Fachinformatiker für Anwendungsentwicklung ist.

Entwicklungsprozess

Das Projekt wird nach dem erweiterten Wasserfallmodell durchgeführt. Diese Methodik bietet mehrere Vorteile für unser Vorhaben.
Das erweiterte Wasserfallmodell ermöglicht eine klare Strukturierung des Projektablaufs. Jede Phase ist deutlich definiert, was eine präzise Planung und Durchführung der einzelnen Projektschritte erlaubten. Dies ist besonders vorteilhaft für uns als Auszubildende, da es uns hilft, den Überblick über den gesamten Entwicklungsprozess zu behalten.
Im Gegensatz zum klassischen Wasserfallmodell bietet die erweiterte Version die Möglichkeit, zwischen den Phasen rückwärtszugehen. Diese Flexibilität erlaubt es uns vorherige Entscheidungen zu überdenken und anzupassen, auf unvorhergesehene Herausforderungen zu reagieren und die Qualität des Endprodukts durch Verbesserungen zu erhöhen.
Die Möglichkeit rückwärtszugehen und Anpassungen vorzunehmen ist für uns Auszubildenden ein großer Vorteil, denn dies ermöglicht es uns, aus Erfahrungen zu lernen und das Projekt kontinuierlich zu optimieren. 
Dies bereitet uns optimal auf zukünftige berufliche Herausforderungen vor. Durch die Kombination von strukturiertem Vorgehen und der Möglichkeit zur Anpassung schafft das erweiterte Wasserfallmodell ideale Voraussetzungen für den erfolgreichen Abschluss unseres Zoo-Management-Projekts im Rahmen unserer Ausbildung bei BITLC GmbH.

Analysephase // differenzieren von IST und SOLL Analyse

Da sich das Gelsenkirchener Zoo im Anfangszustand der IT bewegt, müssen wir von Null anfangen und mit den realen Umständen zurechtkommen. Um mit realen Umständen voranzukommen, müssen wir Objektorientierte Programmierung einsetzen und eine einfach Benutzeroberfläche erstellen. Für diese Aufgabe haben wir uns schnell für C# entschieden. Aktuell besitzt der Zoo nur über eine Liste an Tierarten, Tieren, Tierfutter und Mitarbeiter, welche in das Programm eingebunden werden sollen. Gleichzeitig soll die Anwendung für spätere Herausforderungen leicht zu erweitern und zu warten sein.  Dies schafft man mit einem strukturierten Aufbau und Nutzung sämtlicher Klassen, die die Übersicht aufrecht hält.

Entwurfsphase

Das Projekt wird im Zeitraum vom 15.11.2024 bis 22.11.2024 durchgeführt. Die tägliche Arbeitszeit beträgt 8 Stunden. Gearbeitet wird am Arbeitsplatz vor Ort. Für das Projekt stand ein Zeitrahmen von 48 Stunden zur Verfügung. Dieser wurde in verschiedene Phasen unterteilt, die bei der Softwareentwicklung durchlaufen werden.
Für die Durchführung des Projektes steht ein Arbeitsplatz mit Computer zur Verfügung. Das auf dem Computer installierte Betriebssystem ist Windows 10. Im Rahmen der Projektarbeit wird verschiedene Software verwendet, die bereits installiert ist. Dazu gehören Microsoft Visual Studio 2022, Microsoft Office Word, Microsoft Office Excel, diverse Browser und Notepad++. Diagramme werden mit yEd erstellt. Screenshots werden mit Lightshot erstellt und gegebenenfalls mit paint.net nachbearbeitet.

Projektkosten

Die Gesamtkosten des Projekts setzen sich aus verschiedenen Faktoren zusammen, die im Detail analysiert wurden. Obwohl wir als Praktikanten vergütungsfrei gearbeitet haben, wurden dennoch andere Kosten berücksichtigt, die im Verlauf des Projekts angefallen sind.
Die Stromkosten wurden auf Basis eines durchschnittlichen Verbrauchs von 400 Watt pro Stunde und einem Strompreis von 31,11 Cent pro Kilowattstunde berechnet. Diese Kosten sind vergleichsweise gering, spielen jedoch über die gesamte Laufzeit des Projekts eine Rolle.
Die Internetkosten wurden auf Grundlage eines monatlichen Tarifs von 70 Euro und einer Arbeitszeit von 720 Stunden kalkuliert. Sie stellen einen festen Bestandteil der Infrastrukturkosten dar.
Zur Orientierung wurden die Lohnkosten hypothetisch mit einem monatlichen Praktikantengehalt von 550 Euro angesetzt, verteilt auf eine Arbeitszeit von 720 Stunden. Dies verdeutlicht, wie solche Kosten normalerweise Teil eines Projekts sein könnten.
Für die Fahrten zum Arbeitsplatz wurden die Kosten auf Basis eines Deutschlandtickets in Höhe von 49 Euro pro Monat berechnet. Diese sind ebenfalls ein relevanter Bestandteil der Gesamtkosten.
Die Anschaffungskosten der Computer wurden auf die Gesamtbetriebszeit verteilt, um die anteiligen Kosten für das Projekt zu ermitteln. Dabei wurde die Nutzungsdauer auf insgesamt 8640 Stunden geschätzt.
Die Softwarekosten beinhalten die Lizenzgebühren für Microsoft 365, die pro Monat für beide Personen addiert und auf die Stundenanzahl umgelegt wurden. Diese stellen eine essentielle Ressource für die Projektdurchführung dar.
Die Verpflegungskosten setzen sich aus täglichen Ausgaben für Kaffee und Wasser zusammen. Über die gesamte Projektlaufzeit summieren sich diese Kosten auf einen erheblichen Betrag, der nicht zu vernachlässigen ist.
Die detaillierte Aufschlüsselung zeigt, dass auch ein vergütungsfreies Projekt eine Vielzahl an laufenden Kosten mit sich bringt. Diese sollten bei der Planung und Kalkulation eines Projekts stets berücksichtigt werden, um eine realistische Einschätzung der Gesamtausgaben zu ermöglichen.

Anwendungsfälle

Die Rolle Benutzer kann: 

•	In die drei Zoo-Welten einsehen

•	Zugriff auf die Tierpfleger und deren Aktionen

•	Die Tierübersicht der jeweiligen Welten einsehen

•	Den Zustand des Lagers verfolgen

•	Den Zustand der Tiere beobachten 

•	Die Option die Tiere zu füttern

Projektaufbau

Das Projekt ist aufgeteilt in 2 Bereiche. Zum einen nutzen wir 2 Forms, Form1 für die Verwaltung der einzelnen Zoobereiche und den Zugriff auf die Tierpfleger, die entsprechende Aktionen (Füttern, ins Lager gehen) ausführen können. Diese Form wird statisch erstellt und nach der Initialisierung bei Aufrufen von Form2 versteckt, um später über einen Parent – Aufruf in Form2 wieder sichtbar gemacht zu werden. Form2 enthält die Tiere in den einzelnen Zoobereichen und die Möglichkeit, alle Tiere im entsprechenden Bereich zu füttern. Dafür muss vorher ein Tierpfleger in Form1 ausgewählt und per Objektübergabe an Form2 übergeben werden. Wir
haben uns der Einfachheit halber dazu entschieden, alle Tiere gleichzeitig zu füttern, anstatt einzeln.

Programmstruktur

Program.cs 

Der in Program.cs enthaltene Code wird genau einmal ausgeführt (Bei start des Projekts). Hier werden die einzelnen Zoobereiche initialisiert sowie die Tierpfleger angelegt und die Tierlisten für die einzelnen Bereiche gefüllt. Danach wird eine Hauptform (Form1) erstellt und als Argumente die erstellten Objekte der Zoobereiche sowie die Tierpfleger und der Klasse Tiere übergeben, welche die mit Tieren gefüllten Listen enthält. 

Tier.cs

Die Oberklasse Tier enthält alle notwendigen Eigenschaften eines Tieres (Name, Anzahl, Geschlecht, Zustand). Sie wird genutzt, um später die für die Tierlisten benötigten Objekte vom Datentyp Tier zu erstellen. 

Tiere.cs

Die Klasse Tiere stellt eine Unterklasse der Klasse Tier da und erbt alle benötigten Methoden (get und set Methoden für Name, Anzahl, Geschlecht, Zustand). Hier werden die Listen mit Tieren für die einzelnen Zoobereiche (Afrika, Alaska, Asien) erstellt und gefüllt. Auch wird der Zustand der Tiere festgelegt und über den weiteren Programmablauf verändert. 
Ebenso wird die graphische Anzeige des Zustands der einzelnen Tiere über eine Methode lebensAnzeige mit dem Returnwert Bitmap festgelegt und an die Hauptform (Form1) übergeben. So wird je nach Zustand der Tiere
eine andere Graphik gesetzt. Zuletzt wird über get-Methoden eine Möglichkeit geschaffen, die Tierlisten abzurufen um sie im Weiteren Programmablauf nutzen zu können.

Tierbilder.cs

Die Klasse Tierbilder stellt Bilder der einzelnen Tiere zur Verfügung. Da diese Zuordnung dynamisch über den Tiernamen festgelegt wird haben wir uns aus Gründen der Übersicht dazu entschieden, diesen Programmteil in eine eigene Klasse auszulagern. Als Parameter wird ein Array der Klasse Button übergeben, welches die einzelnen Buttons mit den Tieren enthält und dessen Eigenschaft BackgroundImage über die in der Klasse enthaltenen Methoden einen Wert (ein Bild) zugewiesen bekommt.

Tierpfleger.cs

Die Klasse Tierpfleger enthält die Eigenschaften Name (Name des Tierpflegers), anzFuetterungen (Anzahl der durchgeführten Fütterungen) und lagerCounter (Zählervariabel um die Zeit im Lager zum Auffüllen des Futterinventars eines Tierpflegers festzuhalten). Über die get und set Methoden können diese Werte beliebig gesetzt sowie abgerufen werden.

Lager.cs

Die Klasse Lager dient als „Parkplatz“ für ein Objekt vom Datentyp „Tierpfleger“. Sie wird genutzt, um das Objekt während der Auffüllung des Futterinventars aufzunehmen und nach Beendigung wieder freizugeben.

Zoobereiche (Alaska.cs, Asien.cs, Afrika.cs)

Die Klassen Alaska, Asien und Afrika stellen die drei Zoobereiche dar und enthalten Platzhalter für die Objekte der Datentypen „Tierpfleger“ und „Tiere“ (Listen). Sie enthalten get Methoden für den Tiernamen, die Anzahl, das Geschlecht sowie den Zustand eines Tieres. Des Weiteren sind hier auch die Methoden „setze“Bereich“Tiere“ zur Aufnahme der übergebenen Tierlisten, „fuetterTiere“ zum ändern des Tierzustands bei Fütterung und „getTiere„ zum auslesen der Tierliste enthalten. Da die grafische Darstellung allein über die Windows-Forms Form1 und Form2 geregelt wird findet in diesen drei „Bereichs“ Klassen ausschließlich Datenverarbeitung statt. Daher haben wir uns gegen eine Oberklasse „Zoo“ entschieden, da so eine individuelle Steuerung der einzelnen Zoobereiche möglich ist. 

Codebeispiele:

Hauptform (Form1)

Der Konstruktor der Klasse Form1 (Hauptverwaltung). Die in Program.cs deklarierten und initialisierten Objekte der einzelnen Klassen werden an Form1 übergeben und in vorher festgelegte Platzhaltervariablen der einzelnen Datentypen gelegt. Wir setzten den aktuellen LagerCounter der Tierpfleger zurück (Dieser zählt die Rundenzeit, die ein Tierpfleger im Lager mit dem Auffüllen seines Inventars verbringt, um seine Controls (siehe Tierpfleger Anzeige) wieder zu aktivieren) und Initialisieren danach alle Komponenten der Klasse Form1, um Zugriff auf sie zu erhalten. Danach werden die beiden Controls pbKevin und pbJaqueline (Progress Bars) initialisiert und der Zustand sowohl der Tiere als auch die Controls der Tierpfleger aktualisiert. Zuletzt werden mit setTierpflegerWerte die Namen der Tierpfleger sowie die Anzahl Ihrer Fütterungen initialisiert, um sie in der Hauptverwaltung in Ihren jeweiligen Controls anzuzeigen.
Da die Hauptverwaltung (Form1) als Hauptanzeigefenster agiert und somit nur einmalig erstellt wird, müssen wir nach Änderung von Werten (Tierzustand, Tierpflegerwerte) die auf der Form angezeigten Controls aktualisieren. Die Codezeile: 

this.Activated += (sender, e) => UpdateForm();

sorgt dafür, dass bei Aktivieren der Form1 (Form 2 wird über die Buttons Füttern oder Schließen geschlossen und der Fokus wird wieder auf Form 1 gelegt) die Methode UpdateForm aufgerufen wird. 
Dort wird der Zustand der Tiere (Fütterzustand und das entsprechende Bild), die Werte der einzelnen Tierpfleger (Inventarstatus, Anzahl der Fütterungen) und der LagerCounter (Zeit, die sich der Tierpfleger bereits im Lager befindet) aktualisiert. Zusätzlich prüfen wir, ob eine der Tiergruppen bereits den Zustand = 0 erreicht hat. In diesem Fall sind die Tiere im betreffenden Bereich Tot und der Button für diesen Bereich wird deaktiviert, sodass ein erneuter Zugriff und eine erneute Fütterung nicht mehr möglich sind.

Erstellen der Tierbuttons

Da die Form2 komplett dynamisch erstellt wird, müssen auch die Tierbuttons bei Generierung der Form erstellt werden. Dies geschieht über eine For Schleife, in der ein Buttonarray mit den Buttons gefüllt wird. Die Größe der Buttons sowie die Schriftart und Farbe sind bei allen Buttons gleich, lediglich der Text und der ButtonTag werden dynamisch erstellt. Dabei werden der Tiername sowie das Geschlecht, die Anzahl und der Zustand aus den Listen der jeweiligen Bereichsklassen (Afrika, Asien, Alaska) ausgelesen und als Text bzw. Tag gesetzt. Danach wird über eine If Anweisung die Funktion „erstelleBilder“ aufgerufen, die die jeweiligen Tierbilder übergibt und als Hintergrund in die Buttons einfügt:

GUI

Das GUI der Zooverwaltung ist bewusst einfach und übersichtlich gehalten. Zentral werden die drei Zoobereiche Asien, Afrika und Alaska dargestellt. Es handelt sich um Buttons, über deren Betätigung man in die einzelnen Bereiche kommt, um die enthaltenen Tiere anzuzeigen und die Fütterung zu starten. Als Zusatzinformation ist der aktuelle Zustand der Tiere enthalten, welcher durch eine graphische Hinterlegung der Buttons verdeutlicht wird. Wir haben uns bei der Darstellung der Zustände für folgende graphische Anzeigen entschieden:

Satt:							

Dies ist der Startzustand. Die Tiere sind satt und haben die höchstmögliche Futterstufe. Dieser Zustand wird auch direkt nach einer Fütterung erreicht. 

Fast satt:

Zustand nach Satt. Da wir uns für eine Einteilung der Zustandsstufen von 100 bis 0 entschieden haben, und nach jedem Besuch eines der Tierpflegers in einem Bereich die Zustandsstufe um 25 Punkte Reduziert wird, stellt der Zustand fast Satt 75 Zustandspunkte dar.

Hungrig:						

Zustand nach fast satt. Die Zustandspunkte betragen in dieser Stufe 50.					  
							 
Sehr Hungrig:

Zustand nach sind hungrig. Die Zustandspunkte betragen in dieser Stufe 25. Dies ist die letzte Möglichkeit, die Tiere zu füttern, bevor der Endzustand erreicht wird.

Tot:

Zustand nach sehr hungrig und der aktuelle Endzustand. Die Tiere sind Tot und können auch nicht mehr gefüttert werden. Ein Zugriff auf den Bereich ist durch einen deaktivierten Bereichsbutton nicht mehr möglich.

Tierpfleger Anzeige:

Zeigt die verfügbaren Tierpfleger an. Durch einen Radiobutton hat man die Möglichkeit, zwischen 2 Tierpflegern zu wählen. Die Gesamtanzahl der durchgeführten Fütterungen wird ebenso angezeigt wie das Futterinventar des Tierpflegers. Dieses verringert sich nach jeder Fütterung. Dabei wird der Zustand des Tieres als Berechnungsgrundlage genommen. Die Formel, die wir für die Berechnung gewählt haben, lautet:
Wert des Futterinventars des Tierpflegers - ((100 - Tierzustand) / 5);
Erreicht das Inventar einen Wert <= 15 (Die minimale Menge, die für eine Fütterung benötigt wird) erscheint beim Versuch, Tiere zu füttern, eine Fehlermeldung. Der Tierpfleger muss dann über den Button „Lager“ ins Lager geschickt werden, um sein Futterinventar wieder aufzufüllen. Sobald ein Tierpfleger ins Lager geschickt wird, kann er 3 Runden lang (3 maliges füttern oder betreten eines Zoobereichs durch einen anderen Tierpfleger) keine Aktionen ausführen. Die Anzeige für die Anzahl der durchgeführten Fütterungen zeigt in diesem fall „Im Lager“ an und die Bedienelemente (Radiobutton, Lagerbutton) werden bis zur Rückkehr des Tierpflegers deaktiviert (siehe Anzeige 2). Nach der Rückkehr aus dem Lager ist das Futterinventar des Pflegers wieder auf seinem Maximalwert von 100.

Tierverwaltung:

Die GUI für die Tierverwaltung zeigt die in dem Bereich enthaltenen Tiere. Diese sind nach Geschlecht unterteilt und enthalten sowohl den Namen, die Anzahl der Tiere der entsprechenden Tierart als auch den aktuellen Zustand. Über ein Label wird der Name des aktuell ausgewählten Tierpflegers angezeigt. Der Button „Füttern“ setzt den Zustand aller Tiere im jeweiligen Bereich auf den maximalen Wert von 100 und zieht nach der oben genannten Formel die benötigte Futtermenge vom Inventar des Tierpflegers ab. Über den Button „Schließen“ kommt man zurück in die Hauptverwaltung. Hier ist zu beachten, dass sowohl ein Klick auf den Button „Füttern“ als auch auf den Button „Schließen“ eine Neuberechnung des Zustands aller Tiere im Zoo nach sich zieht, da die hier beschriebenen Aktionen (Tierpfleger geht in einen Zoobereich um Tiere zu füttern oder den Bereich ohne Aktion wieder zu verlassen) eine gewisse Zeit benötigen, in der die Tiere einen Abfall Ihres aktuellen Zustands erfahren. 

Qualitätsanforderungen

Ein zentrales Ziel des Projekts war es, eine Anwendung zu entwickeln, die nicht nur funktional überzeugt, sondern auch durch ihre Benutzerfreundlichkeit besticht. Dafür wurde großer Wert auf eine intuitiv bedienbare grafische Benutzeroberfläche gelegt.
Die Oberfläche wurde so gestaltet, dass sie eine klare Struktur und eine übersichtliche Darstellung aller wichtigen Informationen bietet. Dies erleichtert den Benutzern, insbesondere den Tierpflegern, die Navigation und sorgt dafür, dass alle relevanten Funktionen schnell erreichbar sind. Darüber hinaus war es uns wichtig, dass die Anwendung zügig auf Benutzereingaben reagiert, um reibungslose Abläufe und eine hohe Effizienz im Arbeitsalltag sicherzustellen.

Qualitätssicherung 

Die Qualität der Software wird sichergestellt, indem parallel zur Entwicklung jede Funktionalität direkt getestet wird. Es wird bewusst versucht, Programmfehler durch unerwartetes oder böswilliges Benutzerverhalten oder Fehleingaben zu provozieren. Dabei werden relevante Variablen im Debugger beobachtet, es handelt sich also um EchtzeitWhitebox-Tests. Außerdem wird Microsofts Visual Studio zur Entwicklung eingesetzt, welches alle möglichen Probleme bereits bei der Eingabe analysiert und eventuelle Ungereimtheiten sofort meldet.

Validierungsphase 

Bereits während der Entwicklung haben wir ausgiebig getestet, ob sich die Komponenten so verhalten wie erwartet. Bis auf ein paar minimale Verbesserungspunkten, hat alles so funktioniert wie erwartet. An der Optik unserer GUI mussten wir von Microsoft vorgesetzten Standard übernehmen, da die Zeit für die Implementierung von neuen Layouts und Interfaces einfach nicht da war. Deshalb blieb vieles im Standardbereich und wurde mit besonderen Funktionen, Fonts und Farben ausgeschmückt.

• Abnahme

Bei der Abnahme wurde die Anwendung der gesamten Klasse inklusive dem Dozenten 15 Minuten lang lokal präsentiert. 

• Soll-Ist-Vergleich

Das Projekt hat die anfangs gesteckten Ziele nicht nur erfüllt, sondern in vielen Bereichen deutlich übertroffen. Bereits in der frühen Entwicklungsphase konnten alle minimalen Anforderungen zügig umgesetzt werden. Diese umfassten grundlegende Funktionen, die eine effiziente Zustandsüberprüfung der Tiere und eine optimierte Fütterung ermöglichen sollten.
Im weiteren Verlauf der Entwicklung konnten wir jedoch durch zusätzliche Features und Optimierungen den Funktionsumfang der Anwendung erheblich erweitern. Dabei gingen die realisierten Funktionen weit über die ursprünglich gesetzten Anforderungen hinaus. Zu den erweiterten Features zählen beispielsweise erweiterte Analyse- und Monitoring-Tools, die den Tierpflegern tiefere Einblicke in das Verhalten und die Gesundheit der Tiere ermöglichen, sowie automatisierte Erinnerungen und Empfehlungen zur artgerechten Pflege.
Dieser deutliche Mehrwert zeigt, wie erfolgreich wir die Herausforderungen des Projekts gemeistert haben. Der Soll-Ist-Vergleich verdeutlicht, dass die ursprünglich definierten Ziele nicht nur erreicht, sondern mit einem hohen Maß an Kreativität und technischem Fortschritt übertroffen wurden. Dieses Ergebnis bestätigt den Erfolg unseres Projekts und unterstreicht dessen Potenzial für den praktischen Einsatz im Zoo.

• Dokumentation 

Die Projektdokumentation wurde während der gesamten Dauer des Projekts kontinuierlich und sorgfältig in Word und Excel gepflegt. Sie umfasst detaillierte Beschreibungen aller Schritte und zeigt die exakte Vorgehensweise bei der Planung, Entwicklung und Umsetzung des Projekts.
In Word wurde ein strukturierter Bericht erstellt, der die wichtigsten Aspekte des Projekts dokumentiert: von der Ausgangslage und Zielsetzung über die eingesetzten Technologien bis hin zu einer Zusammenfassung der erzielten Ergebnisse. Neben erläuternden Texten sind auch visuelle Elemente wie Diagramme, Screenshots und enthalten, die die Inhalte verständlich und anschaulich machen.
In Excel wurden vor allem die Planung des Projekts abgebildet. Dazu gehörten detaillierte Zeitpläne, Aufgabenlisten und Ressourcenzuweisungen. Fortschritte wurden regelmäßig aktualisiert, um stets einen klaren Überblick über den Stand des Projekts zu behalten.
Durch diese parallele Dokumentation konnte sichergestellt werden, dass alle relevanten Informationen nicht nur vollständig, sondern auch strukturiert und leicht zugänglich sind. Sie dient nicht nur als Nachweis für die geleistete Arbeit, sondern auch als wertvolles Nachschlagewerk für zukünftige Projekte oder Weiterentwicklungen.

Fazit

Insgesamt war unser gemeinsames Projekt ein großer Erfolg und eine wertvolle Lernerfahrung. Wir konnten nicht nur ein funktionsfähiges Produkt entwickeln, sondern auch unsere technischen Fähigkeiten und unsere Zusammenarbeit stärken. 
Unsere regelmäßige Kommunikation und klare Aufgabenverteilung haben es ermöglicht, effizient zu arbeiten und Probleme schnell zu lösen. Wir haben neue Technologien und Werkzeuge kennengelernt und erfolgreich in unser Projekt integriert. Die zentralen Anforderungen und Meilensteine des Projekts wurden fristgerecht und in hoher Qualität umgesetzt.
